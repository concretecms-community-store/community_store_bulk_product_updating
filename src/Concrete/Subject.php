<?php

namespace Concrete\Package\CommunityStoreBulkProductUpdating;

use Concrete\Core\Application\Application;
use Concrete\Core\Error\UserMessageException;
use Concrete\Package\CommunityStore\Src\CommunityStore\Product\Product;
use Concrete\Package\CommunityStore\Src\CommunityStore\Product\ProductVariation\ProductVariation;
use Doctrine\ORM\EntityManagerInterface;
use Doctrine\ORM\QueryBuilder;
use RuntimeException;

defined('C5_EXECUTE') or die('Access Denied.');

abstract class Subject
{
    /**
     * @var \Concrete\Core\Application\Application
     */
    protected $app;

    public function __construct(Application $app)
    {
        $this->app = $app;
    }

    /**
     * Get the handle that identifies this subject.
     *
     * @return string
     */
    abstract public function getHandle();

    /**
     * Get the name of this subject.
     *
     * @return string
     */
    abstract public function getName();

    /**
     * Override this method to alters the query that returns the IDs of the products to be processed.
     *
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function patchSearchQuery(QueryBuilder $qb)
    {
        return $qb;
    }

    /**
     * Override this method to alters the query that returns the products to be processed.
     *
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function patchResultsQuery(QueryBuilder $qb)
    {
        return $qb;
    }

    /**
     * Create the HTML to be inserted into the webpage in order to create the Vue component.
     *
     * @return string
     */
    abstract public function createVueComponentHtml(UI $ui);

    /**
     * Create the Javascript to be inserted into the webpage in order to create the Vue component.
     *
     * @return string
     */
    abstract public function createVueComponentJavascript();

    /**
     * Create the Javascript to be inserted into the webpage in order to use the Vue component.
     *
     * @return string
     */
    abstract public function insertVueComponentElement();

    /**
     * @param \Concrete\Package\CommunityStore\Src\CommunityStore\Product\Product|\Concrete\Package\CommunityStore\Src\CommunityStore\Product\ProductVariation\ProductVariation $item
     * @param array $rawData
     *
     * @return array|null
     */
    abstract public function normalizeReceivedSubjectData($item, array $rawData);

    /**
     * Process the producs returned by the query generated by the createSearchQuery method.
     */
    public function processProductForSearch(Product $product, array &$result, Cursor &$startingAt = null, Cursor &$lastCursor = null)
    {
        if ($startingAt === null || $this->satisfyStartingAt($startingAt, $product)) {
            $startingAt = null;
            $lastCursor = new Cursor($product->getName(), (int) $product->getPID());
            if ($this->shouldReturnProductForSearch($product)) {
                $result[] = $this->serializeProductForSearch($product, $lastCursor);
            }
        }
        foreach ($product->getVariations() as $productVariation) {
            if ($startingAt === null || $this->satisfyStartingAt($startingAt, $product, $productVariation)) {
                $startingAt = null;
                $lastCursor = new Cursor($productVariation->getProduct()->getName(), $productVariation->getProduct()->getPID(), $productVariation->getVariationSort(), (int) $productVariation->getID());
                if ($this->shouldReturnProductVariationForSearch($productVariation)) {
                    $result[] = $this->serializeProductVariationForSearch($productVariation, $lastCursor);
                }
            }
        }
    }

    /**
     * @param string|mixed key
     * @param mixed $key
     *
     * @ return \Concrete\Package\CommunityStore\Src\CommunityStore\Product\Product|\Concrete\Package\CommunityStore\Src\CommunityStore\Product\ProductVariation\ProductVariation|null
     */
    public function getItemByKey($key)
    {
        if (!is_string($key) || $key === '') {
            return null;
        }
        $matches = null;
        if (!preg_match('/^(?<type>\w+):(?<id>\d+)$/', is_string($key) ? $key : '', $matches)) {
            return null;
        }
        $em = $this->app->make(EntityManagerInterface::class);
        switch ($matches['type']) {
            case 'p':
                $product = $em->find(Product::class, (int) $matches['id']);
                if ($product === null) {
                    throw new UserMessageException(t('Unable to find the requested product (has it been deleted?).'));
                }

                return $this->shouldReturnProductForSearch($product) ? $product : null;
            case 'pv':
                $productVariation = $em->find(ProductVariation::class, (int) $matches['id']);
                if ($productVariation === null) {
                    throw new UserMessageException(t('Unable to find the requested product variation (has it been deleted?).'));
                }

                return $this->shouldReturnProductVariationForSearch($productVariation) ? $productVariation : null;
        }

        return null;
    }

    /**
     * @param \Concrete\Package\CommunityStore\Src\CommunityStore\Product\Product|\Concrete\Package\CommunityStore\Src\CommunityStore\Product\ProductVariation\ProductVariation $item
     *
     * @return array
     */
    public function getItemData($item)
    {
        if ($item instanceof Product) {
            return $this->serializeProductData($item);
        }
        if ($item instanceof ProductVariation) {
            return $this->serializeProductVariationData($item);
        }
        throw new RuntimeException('Invalid item class');
    }

    /**
     * @param \Concrete\Package\CommunityStore\Src\CommunityStore\Product\Product|\Concrete\Package\CommunityStore\Src\CommunityStore\Product\ProductVariation\ProductVariation $item
     */
    public function updateItemData($item, array $newData)
    {
        if ($item instanceof Product) {
            $this->updateProductData($item, $newData);
        } elseif ($item instanceof ProductVariation) {
            $this->updateProductVariationData($item, $newData);
        } else {
            throw new RuntimeException('Invalid item class');
        }
    }

    /**
     * Should the product be returned to search queries?
     *
     * @return bool
     */
    abstract protected function shouldReturnProductForSearch(Product $product);

    /**
     * Should the product variation be returned to search queries?
     *
     * @return bool
     */
    abstract protected function shouldReturnProductVariationForSearch(ProductVariation $productVariation);

    /**
     * Serialize the subject-specific data of a product.
     *
     * @return array
     */
    abstract protected function serializeProductData(Product $product);

    /**
     * Serialize the subject-specific data of a product variation.
     *
     * @return array
     */
    abstract protected function serializeProductVariationData(ProductVariation $productVariation);

    /**
     * Update the product details with the new (already normalized) data.
     */
    abstract protected function updateProductData(Product $product, array $newData);

    /**
     * Update the product variation details with the new (already normalized) data.
     */
    abstract protected function updateProductVariationData(ProductVariation $productVariation, array $newData);

    /**
     * @return bool
     */
    private function satisfyStartingAt(Cursor &$startingAt, Product $product, ProductVariation $productVariation = null)
    {
        $cmp = new \Punic\Comparer();
        $delta = $cmp->compare($product->getName(), $startingAt->pName);
        if ($delta < 0) {
            return false;
        }
        if ($delta > 0) {
            return true;
        }
        $delta = $product->getID() - $startingAt->pID;
        if ($delta < 0) {
            return false;
        }
        if ($delta > 0) {
            return true;
        }
        if ($productVariation === null) {
            return $startingAt->pvSort === null;
        }
        if ($startingAt->pvSort === null) {
            return true;
        }
        $delta = $productVariation->getVariationSort() - $startingAt->pvSort;
        if ($delta < 0) {
            return false;
        }
        if ($delta > 0) {
            return true;
        }
        if ($startingAt->pvID === null) {
            return true;
        }
        $delta = $productVariation->getID() - $startingAt->pvID;
        if ($delta < 0) {
            return false;
        }

        return true;
    }

    /**
     * Serialize a product in order to display data to the clients.
     *
     * @return array
     */
    private function serializeProductForSearch(Product $product, Cursor $cursor)
    {
        return [
            'key' => "p:{$product->getID()}",
            'name' => $product->getName(),
            'sku' => (string) $product->getSKU(),
            'quantitySteps' => $product->getQtySteps() ?: 1,
            'quantityLabel' => (string) $product->getQtyLabel(),
            'subjectData' => $this->serializeProductData($product),
            '_cursor' => $cursor,
        ];
    }

    /**
     * @return array
     */
    private function serializeProductVariationForSearch(ProductVariation $productVariation, Cursor $cursor)
    {
        $product = $productVariation->getProduct();
        /** @var \Concrete\Package\CommunityStore\Src\CommunityStore\Product\Product $product */
        $labels = [];
        foreach ($productVariation->getOptions() as $variationOption) {
            /** @var \Concrete\Package\CommunityStore\Src\CommunityStore\Product\ProductVariation\ProductVariationOptionItem $option */
            $optionItem = $variationOption->getOptionItem();
            /** @var \Concrete\Package\CommunityStore\Src\CommunityStore\Product\ProductOption\ProductOptionItem $optionItem */
            $option = $optionItem->getOption();
            /** @var \Concrete\Package\CommunityStore\Src\CommunityStore\Product\ProductOption\ProductOption $option */
            $labels[] = "{$option->getName()}: {$optionItem->getName()}";
        }

        return [
            'key' => "pv:{$productVariation->getID()}",
            'name' => $product->getName(),
            'labels' => $labels,
            'sku' => (string) $productVariation->getVariationSKU(),
            'quantitySteps' => $product->getQtySteps() ?: 1,
            'quantityLabel' => (string) $product->getQtyLabel(),
            'subjectData' => $this->serializeProductVariationData($productVariation),
            '_cursor' => $cursor,
        ];
    }
}
